Тестовое. Задание на языке C, модуль ядра

От Вас потребуется сделать клон репозитория (пожалуйста, не делайте форк, иначе другие претенденты, выполнящие аналогичное тестовое, легко найдут Ваши наработки):
https://github.com/via8/sbdd

где Вы можете найти модуль со следующими минимальными требованиями:
    1. При загрузке модуля создается блочное устройство (/dev/sbdd).
    2. Размер блочного устройства равен 100 мегабайтам.
    3. С устройства можно читать и писать.
    4. При выгрузке модуля устройство удаляется.
    5. Присутствует печать важных сообщений.
    6. Код собирается на системе с установленным Oracle Linux 8.4/8.5

ВНИМАНИЕ: за основу Вам предстоит взять ветку mq-off (для Вашего же удобства там вырезана поддержка multiqueue)

От Вас же потребуется выполнение следующих пунктов:
    0. Самый сложный пункт для людей, незнакомых с ядром линукса и его блочным уровнем. Необходимо самостоятельно разобраться в исходном коде предоставленного мини-проекта и изучить базовые аспекты написания и сборки модулей для ядра линукс. В этом Вам поможет различная литература, упомянутая в readme проекта, а также некоторые комментарии, оставленные в файлах, и исходники ядра линукс (например, можно использовать https://elixir.bootlin.com/linux/v5.4/source). Изучать абсолютно каждый элемент модуля необходимости нет, поскольку большая доля данного кода выполняет лишь служебную функцию и не несёт большой смысловой нагрузки. Понять, какие части кода являются важнейшими для изучения -- тоже часть задания.
    1. В коде Вы можете увидеть, что под нашим блочником находится "псевдо-девайс", представленный выделенной памятью в RAM. От Вас требуется добавить возможность создавать наш блочник, который будет клонировать и перенаправлять bio запросы на какой-нибудь диск вместо буфера в оперативной памяти. Т.е. как минимум Вам потребуется модифицировать код таким образом, чтобы при подгрузке модуля блочник создавался над нужным нам девайсом, либо создавался уже позже по команде от пользователя, в которой будет указан нужный девайс (предпочтительный вариант). В качестве низлежащего устройства можно подключать жесткий диск (или виртуальный жесткий диск из VirtualBox/QEMU+KVM) или в случае отсутствия возможности использовать дополнительный диск -- использовать любой другой накопитель (например, флешку) или даже блочник созданного LVM-тома на имеющемся накопителе.
    Подсказка: для работы с другим блочником Вам как минимум понадобятся такие функции ядра как blkdev_get_by_path, blkdev_put, get_capacity, bio_clone_fast, bio_set_dev, submit_bio, а также изучите структуру bio и семантику поля bi_end_io.
    2*. Реализовать RAID-массив 1-ого уровня из нескольких девайсов (2-ух достаточно).
    3*. Реализовать RAID-массив 0-ого уровня со страйпом произвольного размера (задаётся пользователем) из произвольного числа девайсов.

Для успешного прохождения тестового достаточно выполнения пунктов 0 и 1. Не бойтесь модифицировать код так, как Вы посчитаете нужным, любые обоснованные манипуляции с ним приветствуются. Полностью идеальной реализации от Вас никто не ожидает, мы лишь желаем увидеть Ваш подход к решению данной задачи.

Дополнительные требования:
    1. По окончании работы от Вас потребуется ссылка на Ваш гитхаб (или другую удобную Вам платформу) с выполненным заданием.
    2. Для упрощения работы проверяющего просьба обозначать принадлежность коммитов к тем или иным пунктам задания.
    3. Необходимо следование текущему код-стайлу, принятому в ядре: https://www.kernel.org/doc/html/v4.10/process/coding-style.html

В Linux Device Drivers рекомендуется прочитать главы:
    1."An Introduction to Device Drivers";
    2. "Building and Running Modules";
    14."The Linux Device Model";
    16. "Block Drivers".

В Linux Kernel Development:
    1. "Introduction to the Linux Kernel";
    2. "Getting Started with the Kernel";
    14. "The Block I/O Layer";
    17. "Devices and Modules".

Некоторые API из книг устарели, поэтому необходимо обратиться к исходникам UEK ядра (версия 5.4.17-2102.203.6) Oracle Linux 8.4 и найти актуальные функции.

Для тестирования можно поставить Oracle Linux 8.4 с UEK ядром (версия 5.4.17-2102.203.6) на VirtualBox или QEMU.


=========================================
=========================================

Петр,

Здравствуйте!

Данное письмо является небольшим дополнением от команды Kernel Space к тексту тестового задания. Сразу скажем, что тестовое задание довольно сложное для начинающего разработчика, хоть и совсем небольшое с точки зрения объема программирования. Тем не менее мы решили сопроводить его этим письмом, чтобы сделать процесс его выполнения чуть проще для Вас. Основной момент, который Вам нужно понимать -- данное задание является в первую очередь обучающим и необходимо в первую очередь Вам, поскольку оно представляет из себя искусственную максимально упрощенную версию того проекта, с которым Вам потенциально предстоит иметь дело. Если сможете разобраться с предоставленным кодом, взяться за дело с реальными production наработками для Вас будет уже значительно проще.

В этом задании от Вас потребуется понять, что из себя представляют ядерные модули Linux, как их писать и как с ними работать. Для этого в конце тестового задания и в проекте на гитхабе есть несколько ссылок на некоторую полезную литературу и ресурсы. Рекомендуется начать базовое знакомство с глав из Linux Kernel Development. По ходу чтения можете уже потихоньку знакомиться с кодом из задания, пытаться его собрать и подгрузить в ядро (важно! не стоит этого делать на своей основной системе, для этого лучше подготовьте виртуальную машину; в тексте задания указаны определенные версии ОС и ядра, но строгой необходимости выбирать именно их нет, однако, рекомендуется поискать ОС хотя бы с той же мажорной версией ядра, чтобы повысить шансы, что данный код соберется на ней).

Сборка выполняется через простую команду make в корне репозитория. Для этого Вам понадобятся установленные пакеты с минимальным набором утилит: make, gcc, ld, etc.
Подробнее о системе сборки ядерных модулей (о том, как нужно писать Makefile'ы для ядерных модулей и о том, как ядерная система сборки выполняет свою работу) можно узнать из:
https://www.kernel.org/doc/Documentation/kbuild

Основные файлы, интересующие Вас это modules.txt и makefiles.txt. Но не стоит сильно глубоко уходить в анализ всей этой документации, достаточно иметь представление о базовых вещах и в будущем знать, куда можно подсмотреть в случае чего.

После сборки, если она прошла успешно на Вашей системе, модуль можно подгрузить в ядро командой:
insmod <path_to_module>
(утилиты для работы с модулями: insmod, rmmod, modprobe, modinfo, etc. также нужно проставить на систему, если они по какой-то причине отсутствуют)

Операции такого рода, разумеется, нужно выполнять от имени root'а, иначе получите ошибку доступа. В случае успешной (или неуспешной) подгрузки модуля, Вы сможете заглянуть в кольцевой буффер ядра и проанализировать сообщения от данного модуля, о том как поэтапно выполнялись те или иные операции (или о том, что пошло не так в процессе подгрузки):
dmesg -T

Если модуль таки удалось подгрузить, Вы сможете обнаружить новое блочное устройство, зарегистрированное в Вашей системе как /dev/sbdd, с которым Вы уже можете попробовать поработать (например, записать и/или прочитать что-то на/с него с помощью утилиты dd).

По завершении работы с модулем, его можно выгрузить командой:
rmmod sbdd
После чего снова заглянуть в логи ради интереса.

Как только завершите базовое знакомство с модулем и поймете основные принципы работы с ним, сможете приступить к выполнению тестового задания. Сразу скажем, что никто не ждет от Вас (как и от других претендентов) стопроцентного его выполнения без ошибок и прочих недочетов. В первую очередь мы хотим увидеть, как Вам удается знакомиться с чем-то новым и разбираться в этом. Вам понадобится изучать некоторые исходники ядра Linux самостоятельно и понимать, как работает та или иная функция. Для этого можете использовать ресурс https://elixir.bootlin.com/linux/v5.4/source (выбирать версию ядра можете в соответствии с Вашими требованиями, однако, помните, что не все дистрибутивы придерживаются mainline версий ядер; в рамках текущего задания этого скорее всего не потребуется, но имейте в виду, что для анализа тех же UEK ядер следует обращаться напрямую к их исходникам: https://github.com/oracle/linux-uek). Кроме того в файлах самого тестового задания местами имеются небольшие комментарии, которые чуть-чуть помогут Вам сориентироваться.

Успехов Вам, и не стесняйтесь демонстрировать нам результаты, какими бы они ни были. Отсутствие результата -- тоже результат, если Вам удастся в чем-то разобраться и сделать какие-то верные шаги.
